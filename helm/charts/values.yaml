# Default values for titiler-eopf
replicaCount: 1

# Optional netrc configuration for accessing private repositories
netrc: ""

image:
  repository: ghcr.io/eopf-explorer/titiler-eopf
  tag: latest
  pullPolicy: IfNotPresent
  command: "uvicorn"
  args:
    - "titiler.eopf.main:app"
    - "--host"
    - "0.0.0.0"
    - "--port"
    - "80"
    - "--workers"
    - "1"

nameOverride: ""
fullnameOverride: ""

terminationGracePeriodSeconds: 30

service:
  type: ClusterIP
  port: 80
  annotations: {}

ingress:
  className: ""
  enabled: false
  annotations:
    {}
    # kubernetes.io/ingress.class: nginx
    # kubernetes.io/tls-acme: "true"
  hosts:
    - host: titiler-eopf.local
      paths: ["/"]
  tls: []
  #  - secretName: titiler-eopf-tls
  #    hosts:
  #      - titiler-eopf.local

extraHostPathMounts: []

imagePullSecrets: []

# Environment variables combining docker-compose.yml and launch.json configurations
env:
  # Application Config
  LOG_LEVEL: "INFO"
  TITILER_EOPF_STORE_URL: "s3://esa-zarr-sentinel-explorer-fra/tests-output/"

  # GDAL Config
  CPL_TMPDIR: /tmp
  GDAL_CACHEMAX: "75%"
  GDAL_DISABLE_READDIR_ON_OPEN: EMPTY_DIR
  GDAL_INGESTED_BYTES_AT_OPEN: "32768"
  GDAL_HTTP_MERGE_CONSECUTIVE_RANGES: "YES"
  GDAL_HTTP_MULTIPLEX: "YES"
  GDAL_HTTP_VERSION: "2"

  # VSI Cache settings
  VSI_CACHE: "TRUE"
  VSI_CACHE_SIZE: "536870912"  # 512MB
  CPL_VSIL_CURL_CACHE_SIZE: "200000000"  # 200MB

  # AWS Configuration
  AWS_ACCESS_KEY_ID: ""  # To be provided via secrets
  AWS_SECRET_ACCESS_KEY: ""  # To be provided via secrets
  AWS_DEFAULT_REGION: "de"
  AWS_ENDPOINT_URL: "https://s3.de.io.cloud.ovh.net/"
  AWS_EC2_METADATA_DISABLED: "true"

# Cache Configuration
cache:
  # Enable tile caching system
  enabled: false
  
  # Cache backend type: "redis", "s3", or "s3-redis"
  backend: "redis"
  
  # TTL settings (seconds)
  ttl:
    default: 3600  # 1 hour
    tiles: 3600
    datasets: 1800  # 30 minutes
  
  # Cache namespace and key generation
  namespace: "titiler-eopf"
  exclude_params:
    - "debug"
    - "timestamp"
    - "auth"
    - "user_id"
    - "session"
    - "token"
  
  # Redis cache configuration
  redis:
    # Use internal Redis deployment (managed by this chart)
    internal:
      enabled: false
    
    # Use external Redis instance
    external:
      enabled: false
      host: ""
      port: 6379
      database: 0
      auth:
        enabled: false
        password: ""
        existingSecret: ""
        existingSecretKey: "redis-password"
  
  # S3 cache configuration
  s3:
    enabled: false
    bucket: ""
    region: "us-east-1"
    endpoint_url: ""
    prefix: "cache/"
    
    # S3 Authentication
    auth:
      # Use inline credentials (not recommended for production)
      access_key_id: ""
      secret_access_key: ""
      session_token: ""
      
      # Use existing secret (recommended)
      existingSecret: ""
      accessKeyIdKey: "access-key-id"
      secretAccessKeyKey: "secret-access-key" 
      sessionTokenKey: "session-token"

  # Admin API configuration
  admin:
    enabled: true
    path_prefix: "/admin/cache"
  
  # Monitoring and metrics
  monitoring:
    enabled: false
    prometheus:
      enabled: false
      path: "/metrics"

# Secrets for sensitive environment variables
# You can create a Kubernetes secret with:
# kubectl create secret generic titiler-eopf-secret --from-literal=AWS_ACCESS_KEY_ID=your_access_key --from-literal=AWS_SECRET_ACCESS_KEY=your_secret_key
secrets:
  secretName: titiler-eopf-secret
  keys:
    - AWS_ACCESS_KEY_ID
    - AWS_SECRET_ACCESS_KEY

resources:
  limits:
    cpu: 1
    memory: 2Gi
  requests:
    cpu: 500m
    memory: 1Gi

serviceAccountName: ""

nodeSelector: {}

tolerations: []

affinity: {}

securityContext: {}

podSecurityContext: {}

# Redis deployment (legacy - use cache.redis for new deployments)
redis:
  # Only one of redis.enabled or redis.external.enabled may be true at one time
  enabled: false
  external:
    enabled: false
    host: ""
    port: 6379

  image:
    repository: redis
    tag: "8.4.0-alpine"
    pullPolicy: IfNotPresent

  service:
    port: 6379
    type: ClusterIP
    annotations: {}

  resources:
    limits:
      cpu: 1
      memory: 2Gi
    requests:
      cpu: 500m
      memory: 1Gi

  nodeSelector: {}
  tolerations: []
  affinity: {}

  persistence:
    enabled: false
    size: 1Gi
    storageClass: ""
    accessModes:
      - ReadWriteOnce

  auth:
    enabled: false
    password: ""  # Only use when deploying redis via this chart, otherwise, use `existingSecret` for external redis usages
    existingSecret: ""
    existingSecretKey: "redis-password"
