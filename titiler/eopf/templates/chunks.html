<!DOCTYPE html>
    <html>
    <head>
        <meta charset='utf-8' />
        <title>EoPF Chunk viz</title>
        <meta name='viewport' content='initial-scale=1,maximum-scale=1,user-scalable=no' />

        <script src='https://unpkg.com/maplibre-gl@2.4.0/dist/maplibre-gl.js'></script>
        <link href='https://unpkg.com/maplibre-gl@2.4.0/dist/maplibre-gl.css' rel='stylesheet' />

        <link href='https://api.mapbox.com/mapbox-assembly/v0.23.2/assembly.min.css' rel='stylesheet'>
        <script src='https://api.mapbox.com/mapbox-assembly/v0.23.2/assembly.js'></script>

        <style>
            body { margin:0; padding:0; width:100%; height:100%;}
            #map { position:absolute; top:0; bottom:0; width:100%; }
            .loading-map {
                position: absolute;
                width: 100%;
                height: 100%;
                color: #FFF;
                background-color: #000;
                text-align: center;
                opacity: 0.5;
                font-size: 45px;
            }
            .loading-map.off{
                opacity: 0;
                -o-transition: all .5s ease;
                -webkit-transition: all .5s ease;
                -moz-transition: all .5s ease;
                -ms-transition: all .5s ease;
                transition: all ease .5s;
                visibility:hidden;
            }
            .middle-center {
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
            }

            .middle-center * {
                display: block;
                padding: 5px;
            }

            #menu {
              left: 0;
              top: 0;
              -o-transition: all .5s ease;
              -webkit-transition: all .5s ease;
              -moz-transition: all .5s ease;
              -ms-transition: all .5s ease;
              transition: all ease .5s;
            }

            @media(max-width: 767px) {
              .mapboxgl-ctrl-attrib {
                  font-size: 10px;
              }
            }

        </style>
    </head>

    <body>

    <div id='menu' class='px12 pt12 absolute z2 bg-white'>
        <div class='txt-h5 mt6 mb6 color-black'>
            Dataset Group
        </div>
        <div class='select-container'>
            <select id='group-selector' class='select select--s select--stroke wmax-full color-black bg-white'>
            </select>
            <div class='select-arrow color-black'></div>
        </div>
        <div class='txt-h5 mt6 mb6 color-black'>
            Multiscale Level
        </div>
        <div class='select-container mb6'>
            <select id='ms-selector' class='select select--s select--stroke wmax-full color-black bg-white'>
            </select>
            <div class='select-arrow color-black'></div>
        </div>
        <div class='txt-h5 mt6 mb6 color-black'>
            Metadata
        </div>
        <div class='mb6 mx6'>
            <div id='group-shape' class='txt-s'></div> 
            <div id='chunk-shape' class='txt-s'></div> 
            <div id='decimation' class='txt-s'></div> 
            <div id='zoom-level' class='txt-s'></div>

        </div>
        
    </div>

    <div id='map'>
      <div id='loader' class="loading-map z3">
        <div class="middle-center">
          <div class="round animation-spin animation--infinite animation--speed-1">
            <svg class='icon icon--l inline-block'><use xlink:href='#icon-satellite'/></svg>
          </div>
        </div>
      </div>
      <div class="zoom-info"><span id="zoom"></span></div>
    </div>

    <script>
    const scope = {metadata: {{ metadata | safe }}}
    const geojson = {{ geojson | safe}}

    /** copy of spherical-mercator.js **/
    var SphericalMercator = (function(){

        // Closures including constants and other precalculated values.
        var cache = {},
            EPSLN = 1.0e-10,
            D2R = Math.PI / 180,
            R2D = 180 / Math.PI,
            // 900913 properties.
            A = 6378137.0,
            MAXEXTENT = 20037508.342789244;


        // SphericalMercator constructor: precaches calculations
        // for fast tile lookups.
        function SphericalMercator(options) {
            options = options || {};
            this.size = options.size || 256;
            if (!cache[this.size]) {
                var size = this.size;
                var c = cache[this.size] = {};
                c.Bc = [];
                c.Cc = [];
                c.zc = [];
                c.Ac = [];
                for (var d = 0; d < 30; d++) {
                    c.Bc.push(size / 360);
                    c.Cc.push(size / (2 * Math.PI));
                    c.zc.push(size / 2);
                    c.Ac.push(size);
                    size *= 2;
                }
            }
            this.Bc = cache[this.size].Bc;
            this.Cc = cache[this.size].Cc;
            this.zc = cache[this.size].zc;
            this.Ac = cache[this.size].Ac;
            this.MAXEXTENT = MAXEXTENT;
        };

        // Convert lon lat to screen pixel value
        //
        // - `ll` {Array} `[lon, lat]` array of geographic coordinates.
        // - `zoom` {Number} zoom level.
        SphericalMercator.prototype.px = function(ll, zoom) {
            var d = this.zc[zoom];
            var f = Math.min(Math.max(Math.sin(D2R * ll[1]), -0.9999), 0.9999);
            var x = Math.round(d + ll[0] * this.Bc[zoom]);
            var y = Math.round(d + 0.5 * Math.log((1 + f) / (1 - f)) * (-this.Cc[zoom]));
            (x > this.Ac[zoom]) && (x = this.Ac[zoom]);
            (y > this.Ac[zoom]) && (y = this.Ac[zoom]);
            //(x < 0) && (x = 0);
            //(y < 0) && (y = 0);
            return [x, y];
        };

        // Convert screen pixel value to lon lat
        //
        // - `px` {Array} `[x, y]` array of geographic coordinates.
        // - `zoom` {Number} zoom level.
        SphericalMercator.prototype.ll = function(px, zoom) {
            var g = (px[1] - this.zc[zoom]) / (-this.Cc[zoom]);
            var lon = (px[0] - this.zc[zoom]) / this.Bc[zoom];
            var lat = R2D * (2 * Math.atan(Math.exp(g)) - 0.5 * Math.PI);
            return [lon, lat];
        };

        // Convert tile xyz value to bbox of the form `[w, s, e, n]`
        //
        // - `x` {Number} x (longitude) number.
        // - `y` {Number} y (latitude) number.
        // - `zoom` {Number} zoom.
        // - `tms_style` {Boolean} whether to compute using tms-style.
        // - `srs` {String} projection for resulting bbox (WGS84|900913).
        // - `return` {Array} bbox array of values in form `[w, s, e, n]`.
        SphericalMercator.prototype.bbox = function(x, y, zoom, tms_style, srs) {
            // Convert xyz into bbox with srs WGS84
            if (tms_style) {
                y = (Math.pow(2, zoom) - 1) - y;
            }
            // Use +y to make sure it's a number to avoid inadvertent concatenation.
            var ll = [x * this.size, (+y + 1) * this.size]; // lower left
            // Use +x to make sure it's a number to avoid inadvertent concatenation.
            var ur = [(+x + 1) * this.size, y * this.size]; // upper right
            var bbox = this.ll(ll, zoom).concat(this.ll(ur, zoom));

            // If web mercator requested reproject to 900913.
            if (srs === '900913') {
                return this.convert(bbox, '900913');
            } else {
                return bbox;
            }
        };

        // Convert bbox to xyx bounds
        //
        // - `bbox` {Number} bbox in the form `[w, s, e, n]`.
        // - `zoom` {Number} zoom.
        // - `tms_style` {Boolean} whether to compute using tms-style.
        // - `srs` {String} projection of input bbox (WGS84|900913).
        // - `@return` {Object} XYZ bounds containing minX, maxX, minY, maxY properties.
        SphericalMercator.prototype.xyz = function(bbox, zoom, tms_style, srs) {
            // If web mercator provided reproject to WGS84.
            if (srs === '900913') {
                bbox = this.convert(bbox, 'WGS84');
            }

            var ll = [bbox[0], bbox[1]]; // lower left
            var ur = [bbox[2], bbox[3]]; // upper right
            var px_ll = this.px(ll, zoom);
            var px_ur = this.px(ur, zoom);
            // Y = 0 for XYZ is the top hence minY uses px_ur[1].
            var bounds = {
                minX: Math.floor(px_ll[0] / this.size),
                minY: Math.floor(px_ur[1] / this.size),
                maxX: Math.floor((px_ur[0] - 1) / this.size),
                maxY: Math.floor((px_ll[1] - 1) / this.size)
            };
            if (tms_style) {
                var tms = {
                    minY: (Math.pow(2, zoom) - 1) - bounds.maxY,
                    maxY: (Math.pow(2, zoom) - 1) - bounds.minY
                };
                bounds.minY = tms.minY;
                bounds.maxY = tms.maxY;
            }
            return bounds;
        };

        // Convert projection of given bbox.
        //
        // - `bbox` {Number} bbox in the form `[w, s, e, n]`.
        // - `to` {String} projection of output bbox (WGS84|900913). Input bbox
        //   assumed to be the "other" projection.
        // - `@return` {Object} bbox with reprojected coordinates.
        SphericalMercator.prototype.convert = function(bbox, to) {
            if (to === '900913') {
                return this.forward(bbox.slice(0, 2)).concat(this.forward(bbox.slice(2,4)));
            } else {
                return this.inverse(bbox.slice(0, 2)).concat(this.inverse(bbox.slice(2,4)));
            }
        };

        // Convert lon/lat values to 900913 x/y.
        SphericalMercator.prototype.forward = function(ll) {
            var xy = [
                A * ll[0] * D2R,
                A * Math.log(Math.tan((Math.PI*0.25) + (0.5 * ll[1] * D2R)))
            ];
            // if xy value is beyond maxextent (e.g. poles), return maxextent.
            (xy[0] > MAXEXTENT) && (xy[0] = MAXEXTENT);
            (xy[0] < -MAXEXTENT) && (xy[0] = -MAXEXTENT);
            (xy[1] > MAXEXTENT) && (xy[1] = MAXEXTENT);
            (xy[1] < -MAXEXTENT) && (xy[1] = -MAXEXTENT);
            return xy;
        };

        // Convert 900913 x/y values to lon/lat.
        SphericalMercator.prototype.inverse = function(xy) {
            return [
                (xy[0] * R2D / A),
                ((Math.PI*0.5) - 2.0 * Math.atan(Math.exp(-xy[1] / A))) * R2D
            ];
        };

        return SphericalMercator;

    })();

    /**
     * from https://github.com/mapbox/tilebelt/blob/master/index.js#L175-L195
     * Get the quadkey for a tile
     *
     * @name tileToQuadkey
     * @param {Array<number>} tile
     * @returns {string} quadkey
     * @example
     * var quadkey = tileToQuadkey([0, 1, 5])
     * //=quadkey
     */
    function tileToQuadkey(tile) {
        var index = '';
        for (var z = tile[2]; z > 0; z--) {
            var b = 0;
            var mask = 1 << (z - 1);
            if ((tile[0] & mask) !== 0) b++;
            if ((tile[1] & mask) !== 0) b += 2;
            index += b.toString();
        }
        return index;
    }

    // return a geojson of Mercator Tiles for a bbox and zoom
    var mercator_grid = (zoom) => {
        let bounds = [...geojson.bbox]
        if (bounds[0] > bounds[2]) {
            bounds[0] = bounds[0] - 360
        }
        const extrema = merc.xyz(bounds, zoom);

        const featCollection = {
            'type': 'FeatureCollection',
            'features': [],
        }

        for (var x = extrema.minX, maxX = extrema.maxX + 1; x < maxX; x++) {
            for (var y = extrema.minY, maxY = extrema.maxY + 1; y < maxY; y++) {
                let extent = merc.bbox(x, y, zoom)
                let w = extent[0]
                let s = extent[1]
                let e = extent[2]
                let n = extent[3]

                let qk = tileToQuadkey([x, y, zoom])
                let feat = {
                    'type': 'Feature',
                    'id': qk,
                    'geometry': {
                        'type': 'Polygon',
                        'coordinates': [
                            [

                                [w, n],
                                [e, n],
                                [e, s],
                                [w, s],
                                [w, n]
                            ]
                        ]
                    },
                    'properties': {
                        'x': x,
                        'y': y,
                        'z': zoom,
                        'quadkey': qk,
                        'tile': `${zoom}-${x}-${y}`
                    }
                }
                featCollection.features.push(feat);
            }
        }
        return featCollection
    }

    const merc = new SphericalMercator({ size: 256 });

    var map = new maplibregl.Map({
      container: 'map',
      style: {
        version: 8,
        sources: {
          'basemap': {
            type: 'raster',
            tiles: [
              'https://tile.openstreetmap.org/{z}/{x}/{y}.png'
            ],
            tileSize: 256,
            attribution:
              '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
          }
        },
        layers: [
          {
            'id': 'basemap',
            'type': 'raster',
            'source': 'basemap',
            'minzoom': 0,
            'maxzoom': 20
          }
        ]
      },
      center: [0, 0],
      zoom: 4
    })

    const add_tiles_grid = (zoom) => {
        if (map.getLayer('mercator-grid')) map.removeLayer('mercator-grid')
        if (map.getLayer('mercator-grid-h')) map.removeLayer('mercator-grid-h')
        if (map.getSource('mercator-grid')) map.removeSource('mercator-grid')

        const grid = mercator_grid(zoom)
        map.addSource('mercator-grid', {
            'type': 'geojson',
            'data': grid
        })

        map.addLayer({
            id: 'mercator-grid',
            type: 'fill',
            source: 'mercator-grid',
            paint: {
            'fill-color': 'hsla(207, 84%, 57%, 0.1)',
            'fill-outline-color': 'hsl(207, 84%, 57%)',
            }
        })

        map.addLayer({
            id: 'mercator-grid-h',
            type: 'fill',
            source: 'mercator-grid',
            paint: {
                'fill-outline-color': '#1386af',
                'fill-color': '#0f6d8e',
                'fill-opacity': 0.3
            },
            filter: ['==', 'quadkey', '']
        })
    }

    const add_chunks_grid = (group, level) => {
        if (map.getLayer('tile-grid')) map.removeLayer('tile-grid')
        if (map.getSource('tile-grid')) map.removeSource('tile-grid')

        return fetch(`{{ grid_endpoint }}?group=${group}&level=${level}`)
            .then(res => {
                if (res.ok) return res.json()
                throw new Error('Network response was not ok.');
            })
            .then(data => {
                map.addSource('tile-grid', {
                    'type': 'geojson',
                    'data': data
                })

                map.addLayer({
                    id: 'tile-grid',
                    type: 'line',
                    source: 'tile-grid',
                    layout: {
                        'line-cap': 'round',
                        'line-join': 'round'
                    },
                    paint: {
                        'line-color': '#e40b34',
                        'line-width': 0.5
                    }
                })
            })
            .catch(err => {
                console.warn(err)
            })
    }

    const update_viz = () => {
        const group = document.getElementById('group-selector').selectedOptions[0].getAttribute("group")
        const level = document.getElementById('ms-selector').selectedOptions[0].getAttribute("level")
        
        const metadata = scope.metadata[group][level]
        document.getElementById('group-shape').innerText = `Array shape: (${metadata.Width}, ${metadata.Height})`
        document.getElementById('chunk-shape').innerText = `Chunk shape: (${metadata.ChunkSize[0]}, ${metadata.ChunkSize[1]})`
        document.getElementById('decimation').innerText = `Decimation: ${(metadata.Decimation).toFixed(1)}`
        document.getElementById('zoom-level').innerText = `Mercator zoom: ${metadata.MercatorZoom}`

        add_chunks_grid(group, level)
        add_tiles_grid(metadata.MercatorZoom)
    }

    document.getElementById('group-selector').addEventListener('change', (e) => {
        document.getElementById('ms-selector').innerHTML = ''
        const group = document.getElementById('group-selector').selectedOptions[0].getAttribute("group")
        scope.metadata[group].forEach((opt, idx) => {
            const option = document.createElement('option')
            option.setAttribute('level', opt.Level)
            option.text = `Level: ${opt.Level}`
            if (idx === 0) option.selected = "selected"
            document.getElementById('ms-selector').appendChild(option);
        });
        update_viz()
    })

    document.getElementById('ms-selector').addEventListener('change', (e) => {
        update_viz()
    })

    map.on('load', () => {
        map.addSource('aoi', {
            'type': 'geojson',
            'data': geojson
        })
        map.addLayer({
            id: 'aoi-polygon',
            type: 'line',
            source: 'aoi',
            layout: {
                'line-cap': 'round',
                'line-join': 'round'
            },
            paint: {
                'line-color': '#000000',
                'line-dasharray': [3, 3],
                'line-width': 1
            }
        })

        let crossing_dateline = false
        let bounds = [...geojson.bbox]
        // Bounds crossing dateline
        if (bounds[0] > bounds[2]) {
            crossing_dateline = true
            bounds[0] = bounds[0] - 360
        }
        map.fitBounds(
            [[bounds[0], bounds[1]], [bounds[2], bounds[3]]]
        )

        const groups = Object.keys(scope.metadata)
        groups.forEach((opt, idx) => {
            const option = document.createElement('option')
            option.setAttribute('group', opt)
            option.text = opt
            if (idx === 0) option.selected = "selected"
            document.getElementById('group-selector').appendChild(option);
        });

        scope.metadata[groups[0]].forEach((opt, idx) => {
            const option = document.createElement('option')
            option.setAttribute('level', opt.Level)
            option.setAttribute('zoom', opt.MercatorZoom)
            option.text = `Level: ${opt.Level}`
            if (idx === 0) option.selected = "selected"
            document.getElementById('ms-selector').appendChild(option);
        });

        map.on('mousemove', (e) => {
            const mouseRadius = 1
            const features = map.queryRenderedFeatures(e.point, {layers: ['mercator-grid']})

            //console.log(features)
            if (features.length > 0) {
                map.getCanvas().style.cursor = 'pointer'
                let filter = features.map(e => {return e.properties.quadkey})
                map.setFilter('mercator-grid-h', ['in', 'quadkey', filter[0]]);

            } else {
                map.getCanvas().style.cursor = 'inherit'
                map.setFilter('mercator-grid-h', ['in', 'quadkey', ''])
            }
        })

        map.on('click', 'mercator-grid', (e) => {
            let props = e.features[0].properties
            document.getElementById('loader').classList.toggle('off')

            const group = document.getElementById('group-selector').selectedOptions[0].getAttribute("group")
            const level = document.getElementById('ms-selector').selectedOptions[0].getAttribute("level")
            const metadata = scope.metadata[group][level]
            const variable_name = `${group}:${metadata.Variables[0]}`

            // the tile_endpoint contains ${z}, ${x}, ${y}
            const x = props.x
            const y = props.y
            const z = props.z
            fetch(`{{ tile_endpoint }}?variables=${variable_name}`)
                .then(res => {
                    if (res.ok) return res.headers
                    throw new Error('Network response was not ok.');
                })
                .then(data => {
                    console.log(data)
                    let html = `<div>tile (${z}-${x}-${y})</div>`
                    html += '<table>'
                    const timing = data.get("server-timing")
                    if (timing) {
                        const dataread = timing.split('=')[1]
                        html += `<tr><td class="align-l">Time (ms)</td><td class="px3 align-r">${dataread}</td></tr>`
                    }
                    html += '</table>'
                    new maplibregl.Popup()
                        .setLngLat(e.lngLat)
                        .setHTML(html)
                        .addTo(map)
                })
                .catch (err => {
                    console.warn(err)
                })
                .then(() => {
                    document.getElementById('loader').classList.toggle('off')
                })
        })

        update_viz()
        document.getElementById('loader').classList.toggle('off')
    })
    </script>

    </body>
    </html>
